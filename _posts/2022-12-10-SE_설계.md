---
title: "[Software Engineering] 설계"
excerpt: "소프트웨어 공학 - 설계"

categories: 
  - Software Engineering
tags:
  - [Software Engineering, Design]

permalink: /Software_Enginnering/Design/

toc: true
toc_sticky: true

date: 2022-12-10
last_modified_at: 2022-12-10
---
### 설계

![설계_](/assets/images/posts_img/%EC%84%A4%EA%B3%84/%EC%84%A4%EA%B3%841.png)

### 좋은 설계가 되기 위한 조건

- 설계서는 요구분석명세서의 내용을 모두 포함해야 한다
- 유지보수가 용이하도록 추적이 가능해야 한다
- 변화에 쉽게 적응할 수 있어야 한다
- 시스템 변경으로 인한 영향이 최소화되도록 국지적이어야 한다
- 설계서는 읽기 쉽고 이해하기 쉽게 작성해야 한다

## 설계의 원리

### 분할과 정복

- 분할 : 큰 소프트웨어 하나를 개발할 때 여러개의 서브시스템으로 세분화해 나누는 작업
- 정복 : 어느 정도 수준까지 분할했다면 말단에 있는 것부터 하나씩 개발하는 작업

**분할과 정복의 원리**

- 프로젝트를 수행할 때 먼저 작은 단위로 분할한 뒤 말단에 있는 작은 시스템부터 개발하면서 하나씩 위로 올라가며 완성
- 우선 **모듈로 분할하는 작업**을 해야 한다.

분할의 기준

- 분산시스템은 클라이언트와 서버로 분할
- 시스템은 여러 서브시스템으로 분할
- 서브시스템은 하나 이상의 패키지로 분할
- 패키지는 유스케이스나 여러 클래스로 분할

분할의 주의사항

- 여러 개의 모듈로 분할하면 모듈끼리 통신 횟수가 많아지면서 모듈로 분할하는 장점보다 복잡도가 오히려 증가할 수 있음
- 설계자는 어느 수준까지 모듈을 분할할지 결정할 때 **복잡도 증가로 인한 부작용**과 **모듈 분할로 얻는 이득을 함께 고려**

### 추상화

- 자신에게 필요한 특징만 표현한 것
- 특정한 목적과 관련된 필수 정보만 추출해 강조
- 관련 없는 세부 사항은 생략해 본질적인 문제에 집중할  수 있도록 하는 작업

- 객체지향 설계에서 추상화의 의미
    - 유사한 특성을 가진 것끼리 그룹화한 뒤 공통점을 뽑아 이름을 붙이는 것
- **과정 추상화**
    - 주어진 문제에 대해 프로그래밍하기 전에 상세부분은 생략하고 전체 흐름만 파악할 수 있는 알고리즘 형태로 작성하는 것
- **데이터 추상화**
    - 데이터와 데이터 구조를 감추는 것으로 대표적인 예가 C++의 클래스
    - 데이터와 메서드를 클래스 형태로 캡슐화해 숨겨 놓고 사용자에게 꼭 필요한 기능만 사용할 수 있게 개방한 구조
- **제어 추상화**
    - 프로그래밍 언어에서 쓰는 제어 구조를 추상화
    - 제어 추상화는 단계가 올라갈 수록 표현이 더욱 간결해지고 특징만 나타낸다는 장점
    - if, for 문 같은 것도 예시가 될 수 있다.

### Pesudo Code

- 의사 코드 , 유사 언어, PDL(Program Description Language) 프로그램 기술 언어
- 모듈의 기능이나 순서 또는 알고리즘의 수행 내용을, 문법적인 제약 없이 정확하게 표현할 수 있는 비형식적인 언어
- 수행 논리를 표현하기 위해 어느 정도의 형식은 갖추고 있음

[장점]

1. 오류 수정 작업을 설계 단계에서 의사코드로 미리하는 것이, 나중에 실제 코드입력, 테스트, 디버그 단계에서 하는 것보다 훨씬 경제적
2. 유지보수시 및 다른 개발자와 의사소통시 원활

### 캡슐화

- 사용자에게 해당 객체의 기능과 사용법만 제공해 사용하기 쉽게 하고 내부는 함부로 변경할 수 없게 감추는 개념
- 블랙 박스와 같은 것으로 클래스를 사용해 서로 관련된 정보와 처리 방식을 같이 묶고 외부에는 감춰두는 것

[장점]

1. 추상화를 통해 문제를 쉽게 개념화 할 수 있음
2. 객체 제공자와 객체 이용자(외부 객체)를 명확하게 분리 가능
3. 메서드의 구현 방법이 바뀌어도 사용자에게는 영향을 미치지 않아 사용하기 쉬움
4. 메서드의 기능만 알면 객체를 쉽게 사용할 수 있음
5. 객체 내 자료구조나 알고리즘이 바뀌어도 다른 객체에 미치는 영향이 적음
6. 캡슐화로 객체 사이의 독립성이 구조적으로 보장
7. 그 객체와 인터페이스로 통신하는 사용자에게는 영향을 주지 않으므로 부담 없이 자료구조를 변경할 수 있음
8. 프로그램을 개발할 때 제공하는 기능만 알면 되므로 사용자(프로그래머)가 모듈을 이해하기 쉬움
9. 모듈 내의 데이터와 알고리즘을 변경하기 쉬우므로 기능을 추가하기도 쉬움

### 정보은닉

- 캡슐화는 캡슐의 내부와 외부를 구분하지만 그 자체로 내부 정보가 외부에 숨겨지지는 않음 이때 정보은닉이 필요함

![설계_](/assets/images/posts_img/%EC%84%A4%EA%B3%84/%EC%84%A4%EA%B3%842.png)

![설계_](/assets/images/posts_img/%EC%84%A4%EA%B3%84/%EC%84%A4%EA%B3%843.png)

### 상속

- 상위 클래스의 모든 것을 하위 클래스가 물려받아 내 것처럼 사용
- **클래스 간의 상속 관계는 속이 빈 삼각형 모양의 화살표를 사용**

[장점]

1. 상속 관계를 이용하면 개별 클래스를 상속 관계로 묶어서 구조를 파악하기 쉬움
2. 상속 관계에 속한 클래스, 데이터, 메서드를 추가하기도 쉬움
3. 데이터와 메서드를 변경할 때 상위에 있는 것만 수정할 수 있음

### 다형성

**오버로딩(중복정의)**

- 매개변수의 개수, 매개변수의 자료형으로 같은 메서드 구분
- 시그니처 : 동일한 메서드가 호출되었을 때 구별할 수 있는 매개변수의 개수나 자료형 같은 요소

**오버라이딩(재정의)**

- 상위 클래스에서 정의한 메서드는 무시하고 하위 클래스에서 다시 정의해 사용하는 것
- 메서드 재정의를 잘못 사용하면 설계 원칙 위배
- **리스코프 교체 원칙 : 상위 클래스의 객체는 언제나 자신의 하위 클래스의 객체로 교체할 수 있어야 함**

## 모듈화

### 모듈

- 규모가 큰 것을 여러 개로 나눈 조각, 소프트웨어 구조를 이루는 기본 단위
- **하나 또는 몇 개의 논리적 기능을 수행하기 위한 명령어의 집단**
- 독립 프로그램도 하나의 모듈이 될 수 있고 함수(메서드)도 하나의 모듈이 될 수 있음
- **소프트웨어 개발에서 큰 문제를 작은 단위로 나누는 것**

### 모듈화의 형태

- 용도가 비슷한 것끼리 묶어놓은 라이브러리 함수, 그래픽 함수
- 추상화된 자료
    - 요구분석 단계
    - 상위 설계(아키텍처 설계)
        - 전체 구조를 파악하여 표현
    - 하위 설계(모듈 설계)
        - 상세한 내용을 다루는 모듈 설계

### 모듈의 특징

- 다른 것과 구별되는 독립적인 기능을 갖는 단위
- 유일한 이름을 가짐
- 모듈에서 또 다른 모듈을 호출할 수 있음
- 다른 프로그램에서도 모듈을 호출할 수 잇음

### 모듈의 원칙

- 모듈화를 하기 전에 먼저 어느 정도의 크기로 나눌 것인지를 생각함
- 문제의 유형이나 특성을 고려해 결정
- 모듈 간의 결합은 느슨하게
- 모듈 내 구성 요소 간의 응집은 강하게

### 모듈화의 장점

- 분할과 정복의 원리가 적용되어 복잡도가 감소
- 변경하기 쉽고 변경으로 인한 영향도 적음
- 프로그램을 효율적으로 관리할 수 있음
- 설계 및 코드를 재사용할 수 있음
- 문제를 이해하기 쉽게 만듬
- 유지보수가 용이
- 오류로 인한 파급효과를 최소화할 수 있음

### 모듈화의 적정 수준

![설계_](/assets/images/posts_img/%EC%84%A4%EA%B3%84/%EC%84%A4%EA%B3%844.png)

### 모듈 간 관계

- 호출 관계 : 모듈 A가 모듈 B를 호출하는 관계
- 데이터 전달 : 매개변수 등을 이용한 데이터 전달로 이루어지는 관계
- 제어 : 모듈 A가 모듈 B에게 제어 플래그를 전달하는 것과 같은 제어를 통해 이루어지는 관계

### 모듈 평가 기준 : 응집도

- 모듈 내부에 존재하는 구성 요소 사이의 밀접한 정도
- **응집도가 높을수록** 꼭 필요한 구성 요소만 모여 있고, **응집도가 낮을수록** 서로 관련성이 적은 구성 요소들이 모임
- **응집도가 가장 높은 것은 모듈 하나가 단일 기능으로 구성된 경**
- 응집도가 가장 낮은 것은 구성 요소가 필요에 의해 모듈에 존재하는 것이 아니라 우연히 함께 묶인 경우

![설계_](/assets/images/posts_img/%EC%84%A4%EA%B3%84/%EC%84%A4%EA%B3%845.png)

**기능적 응집**

- 응집도가 가장 높은 경우로 단일 기능의 요소가 하나의 모듈을 구성
- 단일 기능을 갖는 함수가 해당

**순차적 응집**

- 두 요소가 하나의 모듈로 구성된 경우
- 두 요소가 아주 밀접하므로 하나의 모듈로 묶을 만한 충분한 이유가 됨

**교환적 응집**

- 정보적 응집이라고도 함. 입력을 사용하는 구성 요소가 하나의 모듈로 구성
- 구성 요소가 동일한 출력을 만들어낼 때도 교환적 응집이 됨
- 요소간의 순서는 중요하지 않음

**절차적 응집**

- 순서가 정해진 몇 개의 구성요소가 하나의 모듈로 구성된 경우
- 순차적 응집과는 어떤 구성 요소의 출력이 다음 구성 요소의 입력으로 사용되지 않고 순서에 따라 수행된다는 점이 다름
- 한 요소의 출력이 다음 요소의 입력으로 사용되지 않으므로 순차적 응집보다는 묶인 이유가 조금 약한 편

**시간적 응집**

- 요소의 기능이 각기 다르고 요소의 출력을 입력으로 사용하는 것도, 요소 간에 순서가 정해진 것도 아님
- 구성 요소들이 같은 시간대에 함께 실행된다는 이유로 하나의 모듈로 구성
- 초깃값 설정 모듈이 시간적 응집의 예

**논리적 응집**

- 구성 요소 간에 공통점이 있거나 **관련된 임무가 존재하거나 기능이 비슷해서** 하나의 모듈로 구성된 경우

**우연적 응집**

- 특별한 이유 없이 몇 개의 모듈로 나누는 과정에서 우연히 같이 묶인 것
- 응집도가 가장 낮음

### 모듈 평가 기준 : 결합도

- **모듈과 모듈 사이의 관계에서 관련 정도를 나타냄**
- **간섭하는 관계**와 **좋은 관계(간섭이 적음)**가 있다
- 관련이 적을수록 **상호 의존성이 줄어** 모듈의 **독립성이 높아지고** 독립성이 높으면 **모듈간에 영향 적음**
- 결합에서 좋은 관계는 **데이터만 주고 받는 관계**, 나쁜 관계는 **필요한 데이터만 주지 않고 직접 관여(간섭)**

![설계_](/assets/images/posts_img/%EC%84%A4%EA%B3%84/%EC%84%A4%EA%B3%846.png)

**데이터 결합**

- 가장 좋은 모듈 간 결합
- 모듈이 매개변수를 통해 데이터만 주고 받음 → 간섭 최소화
- 독립성 보장, 관계 단순해서 하나의 모듈을 변경해도 다른 모듈에 미치는 영향이 아주 적음
- 유지보수도 쉽다

**스탬프 결합**

- 필요한 데이터만 주고 받을 수 없고 필요 없는 데이터까지 전체를 주고받아야 하는 경우
- 레코드 전체가 넘어온다.  C언어의 구조체도 스탬프 결합의 예시

**제어 결합**

- 호출하는 모듈이 호출되는 모듈의 내부 구조를 잘 알고 논리적 흐름을 변경하는 관계로 묶이는 관계
- **데이터 결합이 데이터를 매개변수**로 정보를 교환했다면 **제어 결합은 제어플래그를 매개변수**로 사용
- 정보은닉을 크게 위배하여 다른 모듈의 내부에 관여해 관계가 복잡해지고 그로 인해 유지보수도 매우 어려워짐
- **스탬프 결합보다 모듈 간의 결합도가 더 높고 모듈의 독립성은 더 낮음**

**공통 결합**

- 모듈이 공통 변수를 함게 사용 → 전역 변수를 사용할 때 공통 결합이 성립한다
- 데이터를 개별 모듈 내부에서 지역 변수로 선언하여 보완

**내용 결합**

- 모듈 간에 인터페이스를 사요하지 않고 직접 왔다 갔다 하는 것
- 상대 모듈의 데이터를 직접 변경할 수 있어 서로 간섭을 가장 많이 함
- 모듈이 서로 종속되어 독립적으로 설계하거나 변경할 수 없음

**모듈 간의 좋은 관계**

- 모듈 간에는 꼭 필요한 데이터만 주고받는 것이 좋음
- 약한 결합을 유지하는 것이 바람직하므로 인터페이스의 수가 적고 복잡하지 않아야함
- 그러려면 **매개변수로 제어 플래그를 사용하는 것**보다 **데이터를 사용하는 것**이 **유지보수의 용이성**을 높일 수 있어 좋음
- 결론적으로, 설계를 할 때 가장 좋은 형태는 **모듈 간의 결합도는 낮게, 응집도는 높게 하는 것**

## 사용자 인터페이스의 설계

**사용자 인터페이스 설계지침**

- 사용법을 배우기 쉬워야 함
- 사용하기 편리해야 함
- 사용자가 데이터 입력을 제어할 수 있어야 함
- 사용자의 입력에 반응해야 함
- 도움말을 제공해야 함
- 일관성을 유지해야 함
- 입력 작업은 최소로 해야 함
- 효율성을 고려해야 함
- 사용자 오류에 대한 되돌리기 기능을 제공해야 함
- 삭제 또는 취소 버튼 클릭 시 재확인을 요구해야 함
- 사용하게 쉽게 직관적이어야 함 → 메타포

### 메타포(metaphor)

GUI는 데스크탑 메타포를 이용한 **WIMP(Windows, Icons, Menus, Pointing devices)**인터페이스다.

 문서를 표현하는 3가지 메타포

- 스크롤 메타포
- 책 메타포
- 종이 메타포 - 스프레드시트

