---
title: "[Python] 비트 마스킹"
excerpt: "컴퓨터는 내부적으로 모든 자료를 이진수로 표현한다. 이와 같은 특성을 이용해 정수의 이진수 표현을 자료구조로 쓰는 기법을 비트 마스크라고 한다."

categories:
  - Python
tags:
  - [Python, BitMasking, Bit]

permalink: /Python/Bit Masking/

toc: true
toc_sticky: true

date: 2023-01-02
last_modified_at: 2023-01-02
---
### 비트 마스크란?

> 컴퓨터는 내부적으로 모든 자료를 이진수로 표현한다. 이와 같은 특성을 이용해 정수의 이진수 표현을 자료구조로 쓰는 기법을 **비트 마스크**라고 한다.
> 

### 비트 마스크의 개념

컴퓨터의 최소 연산 단위는 bit다. bit는 이진수를 나타내기 위해 0과 1로만 이루어져있는데, 우리는 비트 연산을 통해 약간 ‘꼼수(?)’를 써서 문제를 해결할 수 있다..

예를 들어, 많은 알고리즘 문제에서 방문을 체크하는 리스트가 존재할 수 있는데, 가령 10곳을 우리가 방문 체크해야 한다면 기존에는 아마 아래처럼 리스트를 이용했을 것이다.

```
visited = [False] * 10
```

하지만 비트마스킹으로 똑같은 표현을 할 수 있다.

```
visited = 0b0000000000
```

비트마스크에서 각 비트는 하위 주소(오른쪽)부터 인덱스를 세면 된다. 예를 들어 4번째 도시를 우리가 방문했다고 하면 현재 비트는 visited = 0b0000001000으로 표현되는 것이다.

> ✅ 비트 연산은 삽입, 삭제, 조회가 빠르다.
> 

> ✅ 코드가 간결해진다.
> 

> ✅ 정수 표현으로 Dynamic Programming 문제를 해결할 수 있다.
> 

### **비트 연산**

> AND, OR, XOR, NOT, SHIFT
> 
- AND(&) : 대응하는 두 비트가 모두 1일 때, 1 반환  
- OR(ㅣ) : 대응하는 두 비트 중 모두 1이거나 하나라도 1일때, 1 반환  
- XOR(^) : 대응하는 두 비트가 서로 다를 때, 1 반환
- NOT(~) : 비트 값 반전하여 반환
- SHIFT(>>, <<) : 왼쪽 혹은 오른쪽으로 비트 옮겨 반환
    - 왼쪽 시프트 : `A * 2^B`
    - 오른쪽 시프트 : `A / 2^B`

```
[왼  쪽] 0001 → 0010 → 0100 → 1000 : 1 → 2 → 4 → 8
[오른쪽] 1000 → 0100 → 0010 → 0001 : 8 → 4 → 2 → 1
```

### **삽입**

현재 이진수로 `10101`로 표현되고 있을 때, i번째 비트 값을 1로 변경하려고 한다.

i = 3일 때 변경 후에는 `11101`이 나와야 한다. 이때는 **OR연산을 활용**한다.

```python
10101 | 1 << 3
```

`1 << 3`은 `1000`이므로 `10101 | 01000`이 되어 `11101`을 만들 수 있다.

### **삭제**

반대로 0으로 변경하려면, **AND연산과 NOT 연산을 활용**한다.

```python
11101 & ~1 << 3
```

`~1 << 3`은 `10111`이므로, `11101 & 10111`이 되어 `10101`을 만들 수 있다.

### **조회**

i번째 비트가 무슨 값인지 알려면, **AND연산을 활용**한다.

```python
10101 & 1 << i
```

`3번째 비트 값 : 10101 & (1 << 3) = 10101 & 01000 → 0
4번째 비트 값 : 10101 & (1 << 4) = 10101 & 10000 → 10000`

이처럼 결과값이 0이 나왔을 때는 i번째 비트 값이 0인 것을 파악할 수 있다. (반대로 0이 아니면 무조건 1인 것)